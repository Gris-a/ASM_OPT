# Hash-table optimization

## About

В данном проекте была реализована хеш-таблица методом цепочек в целях тестирования различных хеш-функций и изучения ассемблерных оптимизаций.

Хеш-таблица была основана на том, что коллизии были разрешены путём объединения элементов с одим значением хеша в список. Чтобы вставить новый элемент в таблицу, нужно посчитать его хеш и затем пройтись по цепочке, попутно сравнивая все элементы списка с нашим, что может быть долго, поэтому нашей целью является получить хеш-функцию, дающую наименьшее число коллизий, то есть наиболее равномерное распределение, для анализа которого просчитывалась дисперсия случайной величины $L$ - длины цепочки $D[L] = \sum\frac{(L_{i} - L_{avg})^2}{N}$, где $L_{i}$ - длина цепи соответствующая $i$ позиции в таблице, $L_{avg}$ - получившееся среднее значение длины цепи, $N$ - размер таблицы, который был равен $2^{16} + 1$.

Для тестирования были выбраны следующие хеш-функции:

- ConstHash    - константный 0
- CharHash     - первый символ строки
- StrLenHash   - длина строки
- CheckSumHash - контрольная сумма(сумма всех ASCII-кодов символов строки)
- RotLHash     - подсчёт хеша за счёт битового поворота влево
- RotRHash     - подсчёт хеша за счёт битового поворота вправо
- CRC32Hash    - подсчёт циклического избыточного кода

Хеш-функции тестировались на наборе [hash_functions_test](hash_functions_testing/data/hash_functions_test.txt), затем строились графики зависимости длины цепочки от её номера в таблице и проводился анализ. Для анализа размер таблицы брался примерно в 3 раза меньше размера данных. Далее была выбрана лучшая из полученных хеш-функций и хеш-таблица была оптимизирована на уровне ассемблера.

## Instalation And Testing

Установка:

    git clone https://github.com/Gris-a/ASM_OPT.git
    cd ASM_OPT
    cd hash_functions_testing && make
    cd ../
    cd hash_table_optimizations && make

Запуск тестирования:

    .hash_functions_testing/scripts/runtests.bash
    .hash_table_optimizations/scripts/runtests.bash

После завершения программы результаты тестирования хеш-функций появятся в папке [results](/hash_functions_testing/data/results), результаты профилирования разных этапов оптимизации хеш-таблицы появятся в папке [prof_results](/hash_table_optimizations/data/prof_results). Поледние могут быть визуализированы при помощи `Kcachegrind`.

## Hash Functions Testing

Далее будут подробно описаны используемые хеш-функции и анализ результатов их тестирования.

### ConstHash

Данная хеш-функция возвращает 0.

```C
size_t HashFuncConst(char *key, size_t mod)
{
    return 0;
}
```

При таком подходе становится очевидно, что таблица превращается в односвязный список, сводя на нет все преимущества хеширования, что подтверждают графики:
|                                    |                                     |
|:----------------------------------:|:-----------------------------------:|
|![img](/readme_assets/ConstHash.png)|![img](/readme_assets/1ConstHash.png)|

и полученная дисперсия $D = $.

### CharHash

Данная хеш-функция возвращает первый символ строки.

```C
size_t HashFuncChar(char *key, size_t mod)
{
    return key[0] % mod;
}
```

Из графиков видно, что из-за ограничения количества возможных символов данная хеш функция не даёт хорошего распределения:
|                                   |                                    |
|:---------------------------------:|:----------------------------------:|
|![img](/readme_assets/CharHash.png)|![img](/readme_assets/1CharHash.png)|

что также подтверждается значением дисперсии, равным $D = $.

### CheckSumHash

Данная хеш-функция возвращает сумму всех ASCII-кодов символов строки.

```C
size_t HashFuncCheckSum(char *key, size_t mod)
{
    size_t hash = 0;
    for(char c = *key; c != '\0'; c = *(++key))
    {
        hash += c;
        hash %= mod;
    }
    return hash % mod;
}
```

Сперва мы протестировали данную функцию при большом размере таблицы:
|                                       |                                        |
|:-------------------------------------:|:--------------------------------------:|
|![img](/readme_assets/CheckSumHash.png)|![img](/readme_assets/1CheckSumHash.png)|

Как видно из графика, результаты оказались плохими, так как в нашем датасете не было слов длины даже больше 30, что даёт самое большее возможное значение хеша в ascii('z') * 30 = 3660, в нашем случае вышло около 2000, но приблизив график была обнаружена возможность равномерного распределения ключей по ячейкам таблицы при достаточно малых размерах таблицы:

![img](/readme_assets/CheckSumHash(small).png)

Действительно, распределение стало более равномерным, но разброс оказался довольно большим ввиду большой загруженности таблицы, потому был проведён дополнительный тест, где количество ключей было по-меньше:

![img](/readme_assets/1CheckSumHash(small).png)

Уже получше, но в реальности лучше применять другие хеши, так как данная функция работает приемлимо только на маленьких таблицах, что замедлит работу при большом количестве данных, а так же она коммутативна.

Полученные дисперсии составили соответственно:

### StrLenHash

Данная хеш-функция возвращает длину строки.

```C
size_t HashFuncStrLen(char *key, size_t mod)
{
    return strlen(key) % mod;
}
```

Как и со многими хеш-функциями до этого, очевидно значение ключей будет сильно ограничено, а так же вероятность коллизии очень высока, подтверждение можно увидеть на графике:
|                                     |                                      |
|:-----------------------------------:|:------------------------------------:|
|![img](/readme_assets/StrLenHash.png)|![img](/readme_assets/1StrLenHash.png)|

Десперсия составила $D = $.

### RotLHash

Данная хеш-функция итерирует по всем символам строки `c` операцию `hash = rol(hash) ^ c`.

```C
#define ROL64(num, shift) ((num) << shift) | ((num) >> (sizeof(uint64_t) * 8 - shift))

size_t HashFuncConst(char *key, size_t mod)
{
    size_t hash = 0;
    while(*key != '\0')
    {
        hash = ROL64(hash, 1);
        hash ^= *(key++);
    }
    return hash % mod;
}
```

Что показалось интересным, компилятор даже без оптимизаций может увидеть что мой макрос выполняет именно операцию `rol` и заменяет его на ассемблерную инструкцию, что видно из godbolt-a:

![img](/readme_assets/godbolt_rol.png)

Данная хеш-функция оказалась намного эффективнее предыдущих, так как она осуществляет некоторое количество сдвигов, что позволяет получать довольно большие значения хеша, что ведёт к вероятности заполнения наибольшего числа ячеек таблицы:

![img](/readme_assets/RotLHash.png)

Начало таблицы оказалось наиболее загруженным, что может быть связано со свойствами функции.

Дисперсия составила $D = $.

### RotRHash

Данная хеш-функция итерирует по всем символам строки `c` операцию `hash = ror(hash) ^ c`.

```C
#define ROR64(num, shift) ((num) >> shift) | ((num) << (sizeof(uint64_t) * 8 - shift))

size_t HashFuncRotR(char *key, size_t mod)
{
    size_t hash = 0;
    while(*key != '\0')
    {
        hash = ROR64(hash, 1);
        hash ^= *(key++);
    }
    return hash % mod;
}
```

Вопреки ожиданиям, данная хеш-функция показала себя крайне плохо, по сравнению с RotLHash:

![img](/readme_assets/RotRHash.png)

В приближении:

![img](/readme_assets/1RotRHash.png)

Это может быть связяно с тем, что при сдвиге в право при относительно коротких строках заполняются только старшие биты, поэтому взятие хеша по модулю размера таблицы работает не так как ожидалось.

Дисперсия составила $D = $.

### CRC32

Данная хеш-функция основана на представлении ключа в виде многочлена над $F_2$ и взятии остатка при делении его на какой-то подобранный многочлен, подробная реализация деления многочленов описана [здесь](https://ru.m.wikipedia.org/wiki/CRC32).

```C
size_t HashFuncCRC32(char *key, size_t mod)
{
    uint64_t crc = 0;

    size_t key_len    = strlen(key);
    size_t first_take = key_len % 4;

    for(size_t i = 0; i < first_take; i++)
    {
        crc <<= 8;
        crc |= key[i];
    }
    crc <<= 32;

    for(size_t i = first_take; i < key_len; i += 4)
    {
        crc |= (uint64_t)(*(uint32_t *)(key + i));

        for(size_t j = 0; j < 32; j++)
        {
            if(crc & ((uint64_t)1 << 63))
            {
                crc <<= 1;
                crc  ^= ((uint64_t)0x04C11DB7 << 32);
            }
            else crc <<= 1;
        }
    }

    return (size_t)((crc >> 32) % mod);
}
```

Данная функция оказалась наиболее успешной, так как полученная дисперсия составила $D = $, так же подтверждение можно увидеть из графика:

![img](/readme_assets/CRC32Hash.png)

### Section Conclusion

Таблица с результатами:

| Хеш-функция | Дисперсия |
|:-----------:|:---------:|
|Constant     |           |
|FirstChar    |           |
|StrLen       |           |
|CheckSum     |           |
|RotR         |           |
|RotL         |           |
|CRC32        |           |

CRC 32 показала себя лучше других, к тому же она имеет большой потенциал к оптимизации, поэтому в дальнейшем была выбрана именно она.

## Hash-Table Optimizations

